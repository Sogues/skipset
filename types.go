// Code generated by go run types_gen.go; DO NOT EDIT.
package skipset

import (
	"sync"
	"sync/atomic"
	"unsafe"
)

// Float32Set represents a set based on skip list in ascending order.
type Float32Set struct {
	header *float32Node
	tail   *float32Node
	length int64
}

type float32Node struct {
	value float32
	next  []*float32Node
	mu    sync.Mutex
	flags bitflag
}

func newFloat32Node(value float32, level int) *float32Node {
	return &float32Node{
		value: value,
		next:  make([]*float32Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *float32Node) loadNext(i int) *float32Node {
	return (*float32Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *float32Node) storeNext(i int, node *float32Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *float32Node) cmp(value float32) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewFloat32 return an empty float32 skip set.
func NewFloat32() *Float32Set {
	h, t := newFloat32Node(0, maxLevel), newFloat32Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Float32Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Float32Set) findNodeDelete(value float32, preds *[maxLevel]*float32Node, succs *[maxLevel]*float32Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Float32Set) findNodeInsert(value float32, preds *[maxLevel]*float32Node, succs *[maxLevel]*float32Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockFloat32(preds [maxLevel]*float32Node, highestLevel int) {
	var prevPred *float32Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Float32Set) Insert(value float32) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*float32Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *float32Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockFloat32(preds, highestLocked)
			continue
		}

		nn := newFloat32Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockFloat32(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Float32Set) Contains(value float32) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Float32Set) Delete(value float32) bool {
	var (
		nodeToDelete *float32Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*float32Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *float32Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockFloat32(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockFloat32(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Float32Set) Range(f func(value float32) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Float32Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// Float64Set represents a set based on skip list in ascending order.
type Float64Set struct {
	header *float64Node
	tail   *float64Node
	length int64
}

type float64Node struct {
	value float64
	next  []*float64Node
	mu    sync.Mutex
	flags bitflag
}

func newFloat64Node(value float64, level int) *float64Node {
	return &float64Node{
		value: value,
		next:  make([]*float64Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *float64Node) loadNext(i int) *float64Node {
	return (*float64Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *float64Node) storeNext(i int, node *float64Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *float64Node) cmp(value float64) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewFloat64 return an empty float64 skip set.
func NewFloat64() *Float64Set {
	h, t := newFloat64Node(0, maxLevel), newFloat64Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Float64Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Float64Set) findNodeDelete(value float64, preds *[maxLevel]*float64Node, succs *[maxLevel]*float64Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Float64Set) findNodeInsert(value float64, preds *[maxLevel]*float64Node, succs *[maxLevel]*float64Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockFloat64(preds [maxLevel]*float64Node, highestLevel int) {
	var prevPred *float64Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Float64Set) Insert(value float64) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*float64Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *float64Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockFloat64(preds, highestLocked)
			continue
		}

		nn := newFloat64Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockFloat64(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Float64Set) Contains(value float64) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Float64Set) Delete(value float64) bool {
	var (
		nodeToDelete *float64Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*float64Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *float64Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockFloat64(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockFloat64(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Float64Set) Range(f func(value float64) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Float64Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// Int32Set represents a set based on skip list in ascending order.
type Int32Set struct {
	header *int32Node
	tail   *int32Node
	length int64
}

type int32Node struct {
	value int32
	next  []*int32Node
	mu    sync.Mutex
	flags bitflag
}

func newInt32Node(value int32, level int) *int32Node {
	return &int32Node{
		value: value,
		next:  make([]*int32Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *int32Node) loadNext(i int) *int32Node {
	return (*int32Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *int32Node) storeNext(i int, node *int32Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *int32Node) cmp(value int32) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewInt32 return an empty int32 skip set.
func NewInt32() *Int32Set {
	h, t := newInt32Node(0, maxLevel), newInt32Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Int32Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Int32Set) findNodeDelete(value int32, preds *[maxLevel]*int32Node, succs *[maxLevel]*int32Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Int32Set) findNodeInsert(value int32, preds *[maxLevel]*int32Node, succs *[maxLevel]*int32Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockInt32(preds [maxLevel]*int32Node, highestLevel int) {
	var prevPred *int32Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Int32Set) Insert(value int32) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*int32Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *int32Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockInt32(preds, highestLocked)
			continue
		}

		nn := newInt32Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockInt32(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Int32Set) Contains(value int32) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Int32Set) Delete(value int32) bool {
	var (
		nodeToDelete *int32Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*int32Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *int32Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockInt32(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockInt32(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Int32Set) Range(f func(value int32) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Int32Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// Int16Set represents a set based on skip list in ascending order.
type Int16Set struct {
	header *int16Node
	tail   *int16Node
	length int64
}

type int16Node struct {
	value int16
	next  []*int16Node
	mu    sync.Mutex
	flags bitflag
}

func newInt16Node(value int16, level int) *int16Node {
	return &int16Node{
		value: value,
		next:  make([]*int16Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *int16Node) loadNext(i int) *int16Node {
	return (*int16Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *int16Node) storeNext(i int, node *int16Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *int16Node) cmp(value int16) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewInt16 return an empty int16 skip set.
func NewInt16() *Int16Set {
	h, t := newInt16Node(0, maxLevel), newInt16Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Int16Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Int16Set) findNodeDelete(value int16, preds *[maxLevel]*int16Node, succs *[maxLevel]*int16Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Int16Set) findNodeInsert(value int16, preds *[maxLevel]*int16Node, succs *[maxLevel]*int16Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockInt16(preds [maxLevel]*int16Node, highestLevel int) {
	var prevPred *int16Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Int16Set) Insert(value int16) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*int16Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *int16Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockInt16(preds, highestLocked)
			continue
		}

		nn := newInt16Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockInt16(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Int16Set) Contains(value int16) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Int16Set) Delete(value int16) bool {
	var (
		nodeToDelete *int16Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*int16Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *int16Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockInt16(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockInt16(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Int16Set) Range(f func(value int16) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Int16Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// IntSet represents a set based on skip list in ascending order.
type IntSet struct {
	header *intNode
	tail   *intNode
	length int64
}

type intNode struct {
	value int
	next  []*intNode
	mu    sync.Mutex
	flags bitflag
}

func newIntNode(value int, level int) *intNode {
	return &intNode{
		value: value,
		next:  make([]*intNode, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *intNode) loadNext(i int) *intNode {
	return (*intNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *intNode) storeNext(i int, node *intNode) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *intNode) cmp(value int) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewInt return an empty int skip set.
func NewInt() *IntSet {
	h, t := newIntNode(0, maxLevel), newIntNode(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &IntSet{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *IntSet) findNodeDelete(value int, preds *[maxLevel]*intNode, succs *[maxLevel]*intNode) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *IntSet) findNodeInsert(value int, preds *[maxLevel]*intNode, succs *[maxLevel]*intNode) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockInt(preds [maxLevel]*intNode, highestLevel int) {
	var prevPred *intNode
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *IntSet) Insert(value int) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*intNode
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *intNode
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockInt(preds, highestLocked)
			continue
		}

		nn := newIntNode(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockInt(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *IntSet) Contains(value int) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *IntSet) Delete(value int) bool {
	var (
		nodeToDelete *intNode
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*intNode
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *intNode
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockInt(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockInt(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *IntSet) Range(f func(value int) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *IntSet) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// Uint64Set represents a set based on skip list in ascending order.
type Uint64Set struct {
	header *uint64Node
	tail   *uint64Node
	length int64
}

type uint64Node struct {
	value uint64
	next  []*uint64Node
	mu    sync.Mutex
	flags bitflag
}

func newUint64Node(value uint64, level int) *uint64Node {
	return &uint64Node{
		value: value,
		next:  make([]*uint64Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *uint64Node) loadNext(i int) *uint64Node {
	return (*uint64Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *uint64Node) storeNext(i int, node *uint64Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *uint64Node) cmp(value uint64) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewUint64 return an empty uint64 skip set.
func NewUint64() *Uint64Set {
	h, t := newUint64Node(0, maxLevel), newUint64Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Uint64Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Uint64Set) findNodeDelete(value uint64, preds *[maxLevel]*uint64Node, succs *[maxLevel]*uint64Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Uint64Set) findNodeInsert(value uint64, preds *[maxLevel]*uint64Node, succs *[maxLevel]*uint64Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockUint64(preds [maxLevel]*uint64Node, highestLevel int) {
	var prevPred *uint64Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Uint64Set) Insert(value uint64) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*uint64Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *uint64Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockUint64(preds, highestLocked)
			continue
		}

		nn := newUint64Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockUint64(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Uint64Set) Contains(value uint64) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Uint64Set) Delete(value uint64) bool {
	var (
		nodeToDelete *uint64Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*uint64Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *uint64Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockUint64(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockUint64(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Uint64Set) Range(f func(value uint64) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Uint64Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// Uint32Set represents a set based on skip list in ascending order.
type Uint32Set struct {
	header *uint32Node
	tail   *uint32Node
	length int64
}

type uint32Node struct {
	value uint32
	next  []*uint32Node
	mu    sync.Mutex
	flags bitflag
}

func newUint32Node(value uint32, level int) *uint32Node {
	return &uint32Node{
		value: value,
		next:  make([]*uint32Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *uint32Node) loadNext(i int) *uint32Node {
	return (*uint32Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *uint32Node) storeNext(i int, node *uint32Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *uint32Node) cmp(value uint32) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewUint32 return an empty uint32 skip set.
func NewUint32() *Uint32Set {
	h, t := newUint32Node(0, maxLevel), newUint32Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Uint32Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Uint32Set) findNodeDelete(value uint32, preds *[maxLevel]*uint32Node, succs *[maxLevel]*uint32Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Uint32Set) findNodeInsert(value uint32, preds *[maxLevel]*uint32Node, succs *[maxLevel]*uint32Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockUint32(preds [maxLevel]*uint32Node, highestLevel int) {
	var prevPred *uint32Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Uint32Set) Insert(value uint32) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*uint32Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *uint32Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockUint32(preds, highestLocked)
			continue
		}

		nn := newUint32Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockUint32(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Uint32Set) Contains(value uint32) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Uint32Set) Delete(value uint32) bool {
	var (
		nodeToDelete *uint32Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*uint32Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *uint32Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockUint32(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockUint32(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Uint32Set) Range(f func(value uint32) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Uint32Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// Uint16Set represents a set based on skip list in ascending order.
type Uint16Set struct {
	header *uint16Node
	tail   *uint16Node
	length int64
}

type uint16Node struct {
	value uint16
	next  []*uint16Node
	mu    sync.Mutex
	flags bitflag
}

func newUint16Node(value uint16, level int) *uint16Node {
	return &uint16Node{
		value: value,
		next:  make([]*uint16Node, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *uint16Node) loadNext(i int) *uint16Node {
	return (*uint16Node)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *uint16Node) storeNext(i int, node *uint16Node) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *uint16Node) cmp(value uint16) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewUint16 return an empty uint16 skip set.
func NewUint16() *Uint16Set {
	h, t := newUint16Node(0, maxLevel), newUint16Node(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &Uint16Set{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *Uint16Set) findNodeDelete(value uint16, preds *[maxLevel]*uint16Node, succs *[maxLevel]*uint16Node) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *Uint16Set) findNodeInsert(value uint16, preds *[maxLevel]*uint16Node, succs *[maxLevel]*uint16Node) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockUint16(preds [maxLevel]*uint16Node, highestLevel int) {
	var prevPred *uint16Node
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *Uint16Set) Insert(value uint16) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*uint16Node
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *uint16Node
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockUint16(preds, highestLocked)
			continue
		}

		nn := newUint16Node(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockUint16(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *Uint16Set) Contains(value uint16) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *Uint16Set) Delete(value uint16) bool {
	var (
		nodeToDelete *uint16Node
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*uint16Node
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *uint16Node
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockUint16(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockUint16(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *Uint16Set) Range(f func(value uint16) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *Uint16Set) Len() int {
	return int(atomic.LoadInt64(&s.length))
}

// UintSet represents a set based on skip list in ascending order.
type UintSet struct {
	header *uintNode
	tail   *uintNode
	length int64
}

type uintNode struct {
	value uint
	next  []*uintNode
	mu    sync.Mutex
	flags bitflag
}

func newUintNode(value uint, level int) *uintNode {
	return &uintNode{
		value: value,
		next:  make([]*uintNode, level),
	}
}

// loadNext return `n.next[i]`(atomic)
func (n *uintNode) loadNext(i int) *uintNode {
	return (*uintNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i]))))
}

// storeNext same with `n.next[i] = node`(atomic)
func (n *uintNode) storeNext(i int, node *uintNode) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&n.next[i])), unsafe.Pointer(node))
}

// Return 1 if n is bigger, 0 if equal, else -1.
func (n *uintNode) cmp(value uint) int {
	if n.value > value {
		return 1
	} else if n.value == value {
		return 0
	}
	return -1
}

// NewUint return an empty uint skip set.
func NewUint() *UintSet {
	h, t := newUintNode(0, maxLevel), newUintNode(0, maxLevel)
	for i := 0; i < maxLevel; i++ {
		h.next[i] = t
	}
	h.flags.SetTrue(fullyLinked)
	t.flags.SetTrue(fullyLinked)
	return &UintSet{
		header: h,
		tail:   t,
	}
}

// findNodeDelete takes a value and two maximal-height arrays then searches exactly as in a sequential skip-list.
// The returned preds and succs always satisfy preds[i] > value >= succs[i].
func (s *UintSet) findNodeDelete(value uint, preds *[maxLevel]*uintNode, succs *[maxLevel]*uintNode) int {
	// lFound represents the index of the first layer at which it found a node.
	lFound, x := -1, s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if lFound == -1 && succ != s.tail && succ.cmp(value) == 0 {
			lFound = i
		}
	}
	return lFound
}

// findNodeInsert takes a value and two maximal-height arrays then searches exactly as in a sequential skip-set.
// The returned preds and succs always satisfy preds[i] > value > succs[i].
func (s *UintSet) findNodeInsert(value uint, preds *[maxLevel]*uintNode, succs *[maxLevel]*uintNode) int {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		succ := x.loadNext(i)
		for succ != s.tail && succ.cmp(value) < 0 {
			x = succ
			succ = x.loadNext(i)
		}
		preds[i] = x
		succs[i] = succ

		// Check if the value already in the skip list.
		if succ != s.tail && succ.cmp(value) == 0 {
			return i
		}
	}
	return -1
}

func unlockUint(preds [maxLevel]*uintNode, highestLevel int) {
	var prevPred *uintNode
	for i := highestLevel; i >= 0; i-- {
		if preds[i] != prevPred { // the node could be unlocked by previous loop
			preds[i].mu.Unlock()
			prevPred = preds[i]
		}
	}
}

// Insert insert the value into skip set, return true if this process insert the value into skip set,
// return false if this process can't insert this value, because another process has insert the same value.
//
// If the value is in the skip set but not fully linked, this process will wait until it is.
func (s *UintSet) Insert(value uint) bool {
	level := randomLevel()
	var preds, succs [maxLevel]*uintNode
	for {
		lFound := s.findNodeInsert(value, &preds, &succs)
		if lFound != -1 { // indicating the value is already in the skip-list
			nodeFound := succs[lFound]
			if !nodeFound.flags.Get(marked) {
				for !nodeFound.flags.Get(fullyLinked) {
					// The node is not yet fully linked, just waits until it is.
				}
				return false
			}
			// If the node is marked, represents some other thread is in the process of deleting this node,
			// we need to add this node in next loop.
			continue
		}

		// Add this node into skip list.
		var (
			highestLocked        = -1 // the highest level being locked by this process
			valid                = true
			pred, succ, prevPred *uintNode
		)
		for layer := 0; valid && layer < level; layer++ {
			pred = preds[layer]   // target node's previous node
			succ = succs[layer]   // target node's next node
			if pred != prevPred { // the node in this layer could be locked by previous loop
				pred.mu.Lock()
				highestLocked = layer
				prevPred = pred
			}
			// valid check if there is another node has inserted into the skip list in this layer during this process.
			// It is valid if:
			// 1. The previous node and next node both are not marked.
			// 2. The previous node's next node is succ in this layer.
			valid = !pred.flags.Get(marked) && !succ.flags.Get(marked) && pred.loadNext(layer) == succ
		}
		if !valid {
			unlockUint(preds, highestLocked)
			continue
		}

		nn := newUintNode(value, level)
		for layer := 0; layer < level; layer++ {
			nn.next[layer] = succs[layer]
			preds[layer].storeNext(layer, nn)
		}
		nn.flags.SetTrue(fullyLinked)
		unlockUint(preds, highestLocked)
		atomic.AddInt64(&s.length, 1)
		return true
	}
}

// Contains check if the value is in the skip set.
func (s *UintSet) Contains(value uint) bool {
	x := s.header
	for i := maxLevel - 1; i >= 0; i-- {
		nex := x.loadNext(i)
		for nex != s.tail && nex.cmp(value) < 0 {
			x = nex
			nex = x.loadNext(i)
		}

		// Check if the value already in the skip list.
		if nex != s.tail && nex.cmp(value) == 0 {
			return nex.flags.MGet(fullyLinked|marked, fullyLinked)
		}
	}
	return false
}

// Delete a node from the skip set.
func (s *UintSet) Delete(value uint) bool {
	var (
		nodeToDelete *uintNode
		isMarked     bool // represents if this operation mark the node
		topLayer     = -1
		preds, succs [maxLevel]*uintNode
	)
	for {
		lFound := s.findNodeDelete(value, &preds, &succs)
		if isMarked || // this process mark this node or we can find this node in the skip list
			lFound != -1 && succs[lFound].flags.MGet(fullyLinked|marked, fullyLinked) && (len(succs[lFound].next)-1) == lFound {
			if !isMarked { // we don't mark this node for now
				nodeToDelete = succs[lFound]
				topLayer = lFound
				nodeToDelete.mu.Lock()
				if nodeToDelete.flags.Get(marked) {
					// The node is marked by another process,
					// the physical deletion will be accomplished by another process.
					nodeToDelete.mu.Unlock()
					return false
				}
				nodeToDelete.flags.SetTrue(marked)
				isMarked = true
			}
			// Accomplish the physical deletion.
			var (
				highestLocked        = -1 // the highest level being locked by this process
				valid                = true
				pred, succ, prevPred *uintNode
			)
			for layer := 0; valid && (layer <= topLayer); layer++ {
				pred, succ = preds[layer], succs[layer]
				if pred != prevPred { // the node in this layer could be locked by previous loop
					pred.mu.Lock()
					highestLocked = layer
					prevPred = pred
				}
				// valid check if there is another node has inserted into the skip list in this layer
				// during this process, or the previous is deleted by another process.
				// It is valid if:
				// 1. the previous node exists.
				// 2. no another node has inserted into the skip list in this layer.
				valid = !pred.flags.Get(marked) && pred.loadNext(layer) == succ
			}
			if !valid {
				unlockUint(preds, highestLocked)
				continue
			}
			for i := topLayer; i >= 0; i-- {
				// Now we own the `nodeToDelete`, no other goroutine will modify it.
				// So we don't need `nodeToDelete.loadNext`
				preds[i].storeNext(i, nodeToDelete.next[i])
			}
			nodeToDelete.mu.Unlock()
			unlockUint(preds, highestLocked)
			atomic.AddInt64(&s.length, -1)
			return true
		}
		return false
	}
}

// Range calls f sequentially for each value present in the skip set.
// If f returns false, range stops the iteration.
func (s *UintSet) Range(f func(value uint) bool) {
	x := s.header.loadNext(0)
	for x != s.tail {
		if !x.flags.MGet(fullyLinked|marked, fullyLinked) {
			x = x.loadNext(0)
			continue
		}
		if !f(x.value) {
			break
		}
		x = x.loadNext(0)
	}
}

// Len return the length of this skip set.
// Keep in sync with types_gen.go:lengthFunction
// Special case for code generation, Must in the tail of skipset.go.
func (s *UintSet) Len() int {
	return int(atomic.LoadInt64(&s.length))
}
